/*	SCCS Id: @(#)makedefs.c	3.4	2002/08/14	*/
/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
/* Copyright (c) M. Stephenson, 1990, 1991.			  */
/* Copyright (c) Dean Luick, 1990.				  */
/* NetHack may be freely redistributed.  See license for details. */

#define MAKEDEFS_C	/* use to conditionally include file sections */

#include <stdio.h>

#include "config.h"
#include "objclass.h"
#include "monsym.h"
#include "mondata.h"
#include "dungeon.h"
#include "obj.h"
#include "you.h"
#include "flag.h"
#include "dlb.h"

/* version information */
#include "patchlevel.h"

#define rewind(fp) fseek((fp),0L,SEEK_SET)	/* guarantee a return value */

/* names of files to be generated */
#define MONST_FILE	"pm.h"
#define ONAME_FILE	"onames.h"

#define INCLUDE_TEMPLATE	"include/%s"

static const char *Dont_Edit_Code = "/* This source file is generated by 'makedefs'.  Do not edit. */\n";

static char     in_line[256], filename[600];

int main(int,char **);
void do_objs(void);

extern void objects_init(void);	/* objects.c */

static char *tmpdup(const char *);
static char *limit(char *,int);
static char *eos(char *);

/* input, output, tmp */
static FILE *ifp, *ofp, *tfp;


int main(int argc, char	**argv) {
	// Note: this initializer doesn't do anything except guarantee that we're linked properly.
	objects_init();

	do_objs();

	return 0;
}


static char temp[32];

/* limit a name to 30 characters length */
static char * limit(char *name, int pref) {
	strncpy(temp, name, pref ? 26 : 30);
	temp[pref ? 26 : 30] = 0;
	return temp;
}

void do_objs(void) {
	int i, sum = 0;
	char *c, *objnam;
	int nspell = 0;
	int prefix = 0;
	char class = '\0';
	boolean	sumerr = false;

	filename[0]='\0';
	sprintf(eos(filename), INCLUDE_TEMPLATE, ONAME_FILE);
	if (!(ofp = fopen(filename, WRTMODE))) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(ofp, "/*\tSCCS Id: @(#)onames.h\t3.4\t2002/02/03 */\n\n");
	fprintf(ofp, "%s", Dont_Edit_Code);
	fprintf(ofp, "#ifndef ONAMES_H\n#define ONAMES_H\n\n");

	for(i = 0; !i || objects[i].oc_class != ILLOBJ_CLASS; i++) {
		objects[i].oc_name_idx = objects[i].oc_descr_idx = i;	/* init */
		if (!(objnam = tmpdup(OBJ_NAME(objects[i])))) continue;

		/* make sure probabilities add up to 1000 */
		if(objects[i].oc_class != class) {
			if (sum && sum != 1000) {
			    fprintf(stderr, "prob error for class %d (%d%%)",
				    class, sum);
			    fflush(stderr);
			    sumerr = true;
			}
			class = objects[i].oc_class;
			sum = 0;
		}

		for (c = objnam; *c; c++)
		    if (*c >= 'a' && *c <= 'z') *c -= (char)('a' - 'A');
		    else if (*c < 'A' || *c > 'Z') *c = '_';

		switch (class) {
		    case WAND_CLASS:
			fprintf(ofp,"#define\tWAN_"); prefix = 1; break;
		    case RING_CLASS:
			fprintf(ofp,"#define\tRIN_"); prefix = 1; break;
		    case POTION_CLASS:
			fprintf(ofp,"#define\tPOT_"); prefix = 1; break;
		    case SPBOOK_CLASS:
			fprintf(ofp,"#define\tSPE_"); prefix = 1; nspell++; break;
		    case SCROLL_CLASS:
			fprintf(ofp,"#define\tSCR_"); prefix = 1; break;
		    case AMULET_CLASS:
			/* avoid trouble with stupid C preprocessors */
			fprintf(ofp,"#define\t");
			if(objects[i].oc_material == PLASTIC) {
			    fprintf(ofp,"FAKE_AMULET_OF_YENDOR\t%d\n", i);
			    prefix = -1;
			    break;
			}
			break;
		    case GEM_CLASS:
			/* avoid trouble with stupid C preprocessors */
			if(objects[i].oc_material == GLASS) {
			    fprintf(ofp,"/* #define\t%s\t%d */\n",
							objnam, i);
			    prefix = -1;
			    break;
			}
		    default:
			fprintf(ofp,"#define\t");
		}
		if (prefix >= 0)
			fprintf(ofp,"%s\t%d\n", limit(objnam, prefix), i);
		prefix = 0;

		sum += objects[i].oc_prob;
	}

	/* check last set of probabilities */
	if (sum && sum != 1000) {
	    fprintf(stderr, "prob error for class %d (%d%%)", class, sum);
	    fflush(stderr);
	    sumerr = true;
	}

	fprintf(ofp,"#define\tLAST_GEM\t(JADE)\n");
	fprintf(ofp,"#define\tMAXSPELL\t%d\n", nspell+1);
	fprintf(ofp,"#define\tNUM_OBJECTS\t%d\n", i);

	fprintf(ofp,"\n#endif /* ONAMES_H */\n");
	fclose(ofp);
	if (sumerr) exit(EXIT_FAILURE);
}

static char *tmpdup(const char *str) {
	static char buf[128];

	if (!str) return NULL;
	strncpy(buf, str, 127);
	return buf;
}

static char *eos(char *str) {
	while (*str) str++;
	return str;
}

/*makedefs.c*/
